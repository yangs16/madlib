"""
@file newplda.py_in 

@brief Latent Dirichlet Allocation inference using collapsed Gibbs
sampling algorithm

@namespace newplda

LDA: Driver and auxiliary functions
"""

import plpy
import math
import time

"""
@brief This class defines a PLDATrainer.
"""
class PLDATrainer:
    def __init__(
        self, madlib_schema, data_table, model_table, output_data_table,
        voc_size, topic_num, iter_num, alpha, beta): 
        self.madlib_schema = madlib_schema
        self.data_table = data_table
        self.voc_size = voc_size
        self.topic_num = topic_num
        self.iter_num = iter_num
        self.alpha = alpha
        self.beta = beta
        self.model_table = model_table
        self.output_data_table = output_data_table
        self.work_table_0 = '__work_table_train_0__'
        self.work_table_1 = '__work_table_train_1__'

        plpy.execute('DROP TABLE IF EXISTS %s' % (self.work_table_0))
        plpy.execute("""
            CREATE TEMP TABLE %s(
                distid      INT4,
                docid       INT4, 
                wordcount   INT4, 
                words       INT4[], 
                counts      INT4[], 
                doc_topic   INT4[]
                )
                m4_ifdef(`__GREENPLUM__', 
                    `WITH (APPENDONLY=TRUE,COMPRESSTYPE=QUICKLZ) DISTRIBUTED BY
                    (distid)') 
            """ % (self.work_table_0)) 

        plpy.execute('DROP TABLE IF EXISTS %s' % (self.work_table_1))
        plpy.execute("""
            CREATE TEMP TABLE %s(
                distid      INT4,
                docid       INT4, 
                wordcount   INT4, 
                words       INT4[], 
                counts      INT4[], 
                doc_topic   INT4[]
                )
                m4_ifdef(`__GREENPLUM__', 
                    `WITH (APPENDONLY=TRUE,COMPRESSTYPE=QUICKLZ) DISTRIBUTED BY
                    (distid)') 
            """ % (self.work_table_1)) 

        plpy.execute('DROP TABLE IF EXISTS %s' % (self.model_table))
        plpy.execute("""
            CREATE TABLE %s(
                voc_size        INT4, 
                topic_num       INT4, 
                alpha           FLOAT8, 
                beta            FLOAT8, 
                model      INT4[][] 
                )
                m4_ifdef(`__GREENPLUM__', 
                    `WITH (APPENDONLY=TRUE,COMPRESSTYPE=QUICKLZ) DISTRIBUTED
                    RANDOMLY') 
            """ % (self.model_table)) 

        plpy.execute('DROP TABLE IF EXISTS %s' % (self.output_data_table))
        plpy.execute("""
            CREATE TABLE %s(
                docid               INT4, 
                wordcount           INT4, 
                words               INT4[],
                counts              INT4[],
                topic_count         INT4[],
                topic_assignment    INT4[]
                ) 
                m4_ifdef(`__GREENPLUM__', 
                    `WITH (APPENDONLY=TRUE,COMPRESSTYPE=QUICKLZ) DISTRIBUTED
                    RANDOMLY') 
            """ % (self.output_data_table)) 

    def init_random(self):
        stime = time.time()
        plpy.info('initializing topics randomly..')

        plpy.execute('TRUNCATE TABLE %s' % (self.work_table_0));
        plpy.execute("""
            INSERT INTO %s
            SELECT
                m4_ifdef(`__GREENPLUM__', `gp_segment_id', `1'),
                docid, wordcount, words, counts, 
                %s.__newplda_random_assign(wordcount, %s) 
            FROM %s data
            """ % (
                self.work_table_0, self.madlib_schema, self.topic_num,
                self.data_table)
            )

        etime = time.time()
        plpy.info('\t\ttime elapsed: %.2f seconds' % (etime - stime))

    def gen_model(self):
        stime = time.time()
        plpy.info('\t\tgenerating models..')

        work_table_final = self.work_table_1
        if self.iter_num % 2 == 0:
            work_table_final = self.work_table_0

        plpy.execute('TRUNCATE TABLE %s' % (self.model_table))
        plpy.execute("""
            INSERT INTO %s
            SELECT 
                %d, %d, %f, %f, 
                %s.__newplda_count_topic_agg(
                    words, counts, doc_topic[%d:array_upper(doc_topic, 1)], %d,
                    %d) model FROM
                %s 
            """ % (
                self.model_table, self.voc_size, self.topic_num, self.alpha,
                self.beta, self.madlib_schema, self.topic_num + 1,
                self.voc_size, self.topic_num, work_table_final)
            )

        etime = time.time()
        plpy.info('\t\t\ttime elapsed: %.2f seconds' % (etime - stime))

    def gen_output_data_table(self):
        stime = time.time()
        plpy.info('\t\tgenerating output data table..')

        work_table_final = self.work_table_1
        if self.iter_num % 2 == 0:
            work_table_final = self.work_table_0

        plpy.execute('TRUNCATE TABLE %s' % (self.output_data_table))
        plpy.execute("""
            INSERT INTO %s
            SELECT 
                docid, wordcount, words, counts, doc_topic[1:%d] topic_count,
                doc_topic[%d:array_upper(doc_topic,1)] topic_assignment
            FROM
                %s work_table
            """ % (self.output_data_table, self.topic_num, self.topic_num + 1,
            work_table_final))

        etime = time.time()
        plpy.info('\t\t\ttime elapsed: %.2f seconds' % (etime - stime))

    def iteration(self, it):  
        stime = time.time()

        work_table_in = self.work_table_0
        if it % 2 == 0 :
            work_table_in = self.work_table_1

        work_table_out = self.work_table_1
        if it % 2 == 0 :
            work_table_out = self.work_table_0

        plpy.info('iteration [%d]...' % (it))
        plpy.info('\t\tjoining & sampling ..')
        plpy.execute('TRUNCATE TABLE %s' % (work_table_out))
        plpy.execute("""
            INSERT INTO %s
            SELECT  
                distid, docid, wordcount, words, counts,  
                %s.__newplda_gibbs_sample(
                    words, counts, doc_topic, model, %f, %f, %d, %d, 1)
            FROM
            (
                SELECT
                    dcz.distid, dcz.docid, dcz.wordcount, dcz.words,
                    dcz.counts, dcz.doc_topic, chunk.model 
                FROM
                (
                    SELECT
                        distid, docid, model
                    FROM
                    (
                        SELECT
                            %s.__newplda_count_topic_agg(
                                words, counts,
                                doc_topic[%d:array_upper(doc_topic, 1)], %d, %d) model 
                        FROM %s dcz 
                    ) t1,
                    (
                       SELECT
                           distid, min(docid) docid 
                       FROM %s dcz
                       GROUP BY distid
                    ) t2
                )chunk 
                RIGHT JOIN %s dcz
                ON (dcz.distid = chunk.distid AND dcz.docid = chunk.docid)
                ORDER BY distid, docid
            ) jd
            """ % (
                work_table_out, self.madlib_schema, self.alpha, self.beta,
                self.voc_size, self.topic_num, self.madlib_schema,
                self.topic_num + 1, self.voc_size, self.topic_num,
                work_table_in, work_table_in, work_table_in)
            )

        etime = time.time()
        plpy.info('\t\ttime elapsed: %.2f seconds' % (etime - stime))

    def run(self):
        stime = time.time()
        plpy.info('start training process..')

        self.init_random()
        for it in range(1, self.iter_num + 1):
            self.iteration(it)
        self.gen_model()
        self.gen_output_data_table()

        etime = time.time()
        plpy.info('finished, time elapsed: %.2f seconds' % (etime - stime))

"""
@brief This class defines a PLDAPredictor
"""
class PLDAPredictor:
    def __init__(
        self, madlib_schema, test_table, model_table, output_table, iter_num):
        self.madlib_schema = madlib_schema
        self.test_table = test_table 
        self.model_table = model_table
        self.iter_num = iter_num

        rv = plpy.execute("""
            SELECT 
                voc_size, topic_num, alpha, beta 
            FROM %s
                """ % (self.model_table)) 
        self.voc_size = rv[0]['voc_size']
        self.topic_num = rv[0]['topic_num']
        self.alpha = rv[0]['alpha']
        self.beta = rv[0]['beta']

        self.doc_topic = output_table
        self.work_table_0 = '__work_table_pred_0__'
        self.work_table_1 = '__word_table_pred_1__'
        
        plpy.execute('DROP TABLE IF EXISTS %s' % (self.work_table_0)) 
        plpy.execute("""
            CREATE TEMP TABLE %s(
                distid      INT4,
                docid       INT4, 
                wordcount   INT4, 
                words       INT4[], 
                counts      INT4[], 
                doc_topic   INT4[]
                )
                m4_ifdef(`__GREENPLUM__', 
                    `WITH (APPENDONLY=TRUE,COMPRESSTYPE=QUICKLZ) DISTRIBUTED BY
                    (distid)') 
            """ % (self.work_table_0)) 

        plpy.execute('DROP TABLE IF EXISTS %s' % (self.work_table_1))
        plpy.execute("""
            CREATE TEMP TABLE %s(
                distid      INT4,
                docid       INT4, 
                wordcount   INT4, 
                words       INT4[], 
                counts      INT4[], 
                doc_topic   INT4[]
                )
                m4_ifdef(`__GREENPLUM__', 
                    `WITH (APPENDONLY=TRUE,COMPRESSTYPE=QUICKLZ) DISTRIBUTED BY
                    (distid)') 
            """ % (self.work_table_1)) 

        plpy.execute('DROP TABLE IF EXISTS %s' % self.doc_topic)
        plpy.execute("""
            CREATE TABLE %s(
                docid               INT4, 
                wordcount           INT4,
                words               INT4[],
                counts              INT4[],
                topic_count         INT4[], 
                topic_assignment    INT4[]
                )
                m4_ifdef(`__GREENPLUM__', 
                    `WITH (APPENDONLY=TRUE,COMPRESSTYPE=QUICKLZ) DISTRIBUTED BY
                    (docid)') 
            """ % (self.doc_topic)) 

    def init_random(self):
        stime = time.time()
        plpy.info('initializing topics randomly..')

        plpy.execute('TRUNCATE TABLE %s' % (self.work_table_0));
        plpy.execute("""
            INSERT INTO %s
            SELECT 
                m4_ifdef(`__GREENPLUM__', `gp_segment_id', `1'),
                docid, wordcount, words, counts,
                %s.__newplda_random_assign(wordcount, %s) doc_topic 
            FROM %s data
            """ % (
                self.work_table_0, self.madlib_schema,
                self.topic_num, self.test_table)
            ) 

        etime = time.time()
        plpy.info('\t\ttime elapsed: %.2f seconds' % (etime - stime))

    def gen_output_table(self):
        plpy.execute('TRUNCATE TABLE %s' % (self.doc_topic))
        plpy.execute("""
            INSERT INTO %s
            SELECT 
                docid, wordcount, words, counts, doc_topic[1:%d] topic_count,
                doc_topic[%d:array_upper(doc_topic,1)] topic_assignment
            FROM %s work_table_out
            """ % (
                self.doc_topic, self.topic_num, self.topic_num + 1,
                self.work_table_1))

    def infer(self):  
        stime = time.time()
        plpy.info('infering..')

        plpy.execute("""
            INSERT INTO %s
            SELECT  
                distid, docid, wordcount, words, counts,
                %s.__newplda_gibbs_sample(
                    words, counts, doc_topic, model, %f, %f, %d, %d, %d)
            FROM
            (
                SELECT 
                    dcz.distid, dcz.docid, dcz.wordcount, dcz.words, dcz.counts,
                    dcz.doc_topic, model
                FROM
                (
                    SELECT 
                        distid, docid, model
                    FROM
                    (
                       SELECT
                           distid, min(docid) docid
                       FROM %s dcz
                       GROUP BY distid
                    ) t1, %s model
                ) chunk RIGHT JOIN %s dcz ON (dcz.distid = chunk.distid AND
                dcz.docid = chunk.docid)
                ORDER BY distid, docid
            ) jd
            """ % (
                self.work_table_1, self.madlib_schema, self.alpha, self.beta,
                self.voc_size, self.topic_num, self.iter_num,
                self.work_table_0, self.model_table, self.work_table_0))

        etime = time.time()
        plpy.info('\t\ttime elapsed: %.2f seconds' % (etime - stime))

    def run(self):
        stime = time.time()
        plpy.info('start prediction process..')

        self.init_random()
        self.infer()
        self.gen_output_table()

        etime = time.time()
        plpy.info('finished, time elapsed: %.2f seconds' % (etime - stime))

"""
@brief This function provides the entry for the plda training process. 
@param madlib_schema        MDALib schema
@param data_table           Training data table
@param voc_size             Size of vocabulary
@param topic_num            Number of topics
@param iter_num             Number of iterations
@param alpha                Dirichlet parameter for per-document topic multinomial
@param beta                 Dirichlet parameter for per-topic word multinomial
@param model_table          Learned model table
@param output_data_table    Output data table
"""
def plda_train(
    madlib_schema, train_table, model_table, output_data_table, voc_size,
    topic_num, iter_num, alpha, beta):

    __assert(
        train_table != '',  
        'invalid argument:  Non-empty string expected for train_table')
    __assert(
        model_table != '',
        'invalid argument:  Non-empty string expected for model_table')
    __assert(
        output_data_table != '',
        'invalid argument:  Non-empty string expected for output_data_table')
    __assert(
        voc_size > 0, 
        'invalid argument: Positive integer expected for voc_size')
    __assert(
        topic_num > 0, 
        'invalid argument: Positive integer expected for topic_num')
    __assert(
        iter_num >= 0,
        'invalid argument: Positive integer expected for iter_num')
    __assert(
        alpha > 0, 
        'invalid argument: Positive real expected for alpha')
    __assert(
        beta > 0, 
        'invalid argument: Positive real expected for beta')

    __warn(
        voc_size <= 1e5,
        """the voc_size is very large: %d - make sure that the system has
        enough memory or reduce the vocabulary size""" % (voc_size))
    __warn(
        topic_num <= 1e3,
        """the topic_num is large: %d - make sure that the system has enough
        memory or reduce the topic number"""% (topic_num))

    __validate_data_table(train_table, voc_size)
    convt_table = __convert_data_table(madlib_schema, train_table)
    pt = PLDATrainer(
        madlib_schema, convt_table, model_table, output_data_table, voc_size,
        topic_num, iter_num, alpha, beta) 
    pt.run()

"""
@brief This function provides the entry for the plda prediction process.
@param test_table       name of the testing dataset table
@param model_table      name of the model table
@param iter_num         number of iterations
@param output_table     name of output table
"""
def plda_predict(
    madlib_schema, test_table, model_table, output_data_table, iter_num = 20):

    __assert(
        test_table != '',  
        'invalid argument:  Non-empty string expected for test_table')
    __assert(
        model_table != '', 
        'invalid argument:  Non-empty string expected for model_table')
    __assert(
        output_data_table != '',
        'invalid argument:  Non-empty string expected for output_data_table')
    __assert(
        iter_num >= 0, 
        'invalid argument: Positive integer expected for iter_num')
    __warn(
        iter_num <= 20,
        """the iter_num is large: %d - a smaller iter_num (e.g. 20) should be
        good enough""" % (iter_num))

    __check_model_table(model_table)
    rv = plpy.execute('SELECT voc_size FROM %s' % (model_table))
    voc_size = rv[0]['voc_size']
    __validate_data_table(test_table, voc_size)    

    convt_table = __convert_data_table(madlib_schema, test_table)
    pp = PLDAPredictor(
        madlib_schema, convt_table, model_table, output_data_table, iter_num) 
    pp.run()

"""
@brief Get the per-topic description by top-k words
@param model_table  The model table generated by the training process
@param vocab_table  The vocabulary table
@param top_k        The top k words for topic description
@param desc_table   The output table for storing the per-topic word description
"""
def get_topic_desc(
    madlib_schema, model_table, vocab_table, desc_table, top_k = 15):
    __assert(
        model_table != '' and
        vocab_table != '' and
        desc_table != '',
        'invalid argument:  Non-empty string expected for table names')

    __assert(
        top_k > 0,
        'invalid argument: Positive integer expected for top_k')

    __check_model_table(model_table) 
    __check_vocab_table(vocab_table)

    plpy.execute('DROP TABLE IF EXISTS __newplda_topic_word_count__')
    plpy.execute("""
        CREATE TEMP TABLE __newplda_topic_word_count__(
            topicid INT4, 
            word_count INT4[], 
            beta FLOAT8
        )
        m4_ifdef(
            `__GREENPLUM__', 
            `WITH (APPENDONLY=TRUE, COMPRESSTYPE=QUICKLZ) DISTRIBUTED BY
            (topicid)') 
        """)

    plpy.execute("""
        INSERT INTO __newplda_topic_word_count__
        SELECT 
            generate_series(1, topic_num) topicid,
            %s.__newplda_util_unnest(
                %s.__newplda_util_transpose(model[1:array_upper(model, 1) - 1])) word_count,
            beta
        FROM %s model
        """ % (madlib_schema, madlib_schema, model_table))

    plpy.execute('DROP TABLE IF EXISTS __newplda_topic_word_dist__')
    plpy.execute("""
        CREATE TEMP TABLE __newplda_topic_word_dist__(
            topicid INT4, 
            word_dist FLOAT[]
        )
        m4_ifdef(
            `__GREENPLUM__', 
            `WITH (APPENDONLY=TRUE, COMPRESSTYPE=QUICKLZ) DISTRIBUTED BY
            (topicid)') 
        """)

    plpy.execute("""
        INSERT INTO __newplda_topic_word_dist__
        SELECT 
            topicid, 
            %s.__newplda_util_norm_with_smoothing(word_count, beta) dist 
        FROM
            __newplda_topic_word_count__
        """ % (madlib_schema))

    plpy.execute('DROP TABLE IF EXISTS %s' % (desc_table))
    plpy.execute("""
        CREATE TABLE %s (topicid INT4, wordid INT4, prob FLOAT, word TEXT)
        m4_ifdef(
            `__GREENPLUM__', 
            `WITH (APPENDONLY=TRUE, COMPRESSTYPE=QUICKLZ) DISTRIBUTED BY
            (topicid)') 
        """ % (desc_table))

    plpy.execute("""
        INSERT INTO %s
        SELECT
            topicid, t2.wordid, prob, word
        FROM
        (
            SELECT
                topicid, wordid, prob,
                rank() OVER(PARTITION BY topicid ORDER BY prob DESC) r
            FROM
            (
                SELECT 
                    topicid, 
                    generate_series(0, array_upper(word_dist, 1) - 1) wordid,
                    unnest(word_dist) prob
                FROM
                    __newplda_topic_word_dist__
            ) t1
        ) t2, %s vocab
        WHERE t2.r < %d AND t2.wordid = vocab.wordid
        """ % (desc_table, vocab_table, top_k))

"""
@brief Get the per-topic word counts from the model table
@param model_table     The model table generated by the training process
@param output_table    The output table for storing the per-topic word counts
"""
def get_topic_word_count(madlib_schema, model_table, output_table):
    __assert(
        model_table != '' and
        output_table != '',
        'invalid argument:  Non-empty string expected for table names')

    __check_model_table(model_table) 

    plpy.execute('DROP TABLE IF EXISTS %s' % (output_table))
    plpy.execute("""
        CREATE TABLE %s (
            topicid INT4, 
            word_count INT4[]) 
        m4_ifdef(
            `__GREENPLUM__', 
            `WITH (APPENDONLY=TRUE, COMPRESSTYPE=QUICKLZ) DISTRIBUTED BY
            (topicid)') 
        """ % (output_table)) 

    plpy.execute("""
        INSERT INTO %s 
        SELECT 
            generate_series(1, topic_num) topicid,   
            %s.__newplda_util_unnest(
                %s.__newplda_util_transpose(model[1:array_upper(model, 1) - 1])) word_count
        FROM %s model
        """ % (output_table, madlib_schema, madlib_schema, model_table))

"""
@brief Get the per-word topic counts from the model table
@param model_table     The model table generated by the training process
@param output_table    The output table for storing the per-word topic counts
"""
def get_word_topic_count(madlib_schema, model_table, output_table):
    __assert(
        model_table != '' and
        output_table != '',
        'invalid argument: non-empty string expected for table names')

    __check_model_table(model_table) 

    plpy.execute('DROP TABLE IF EXISTS %s' % (output_table))
    plpy.execute("""
        CREATE TABLE %s ( 
            wordid INT4, 
            topic_count INT4[]) 
        m4_ifdef(
            `__GREENPLUM__', 
            `WITH (APPENDONLY=TRUE, COMPRESSTYPE=QUICKLZ) DISTRIBUTED BY
            (wordid)') 
        """ % (output_table)) 

    plpy.execute("""
        INSERT INTO %s 
        SELECT 
            generate_series(0, voc_size - 1) wordid,   
            %s.__newplda_util_unnest(model[1:array_upper(model, 1) - 1]) topic_count
        FROM %s
        """ % (output_table, madlib_schema, model_table))

"""
@brief Normalize the vector using L1 norm with smoothing
@param vector   The vector to be normalized
@param smooth   The smoothing parameter
@return         The normalized vector
"""
def l1_norm_with_smoothing(vector, smooth):
    norm = sum(map(lambda r: abs(r), vector))
    norm += abs(smooth) * len(vector)
    return map(lambda r: float(r + abs(smooth)) / norm, vector)

"""
@brief Checks the vocabulary and converts non-continous wordids into continuous
integers ranging from 0 to voc_size - 1. 
@param vocab_table  The vocabulary table in the form of 
                    <wordid::INT4, word::text>
@param out_table    The normalized vocabulary table 
"""
def norm_vocab(vocab_table, out_table):
    __check_vocab_table(vocab_table)
    plpy.execute('DROP TABLE IF EXISTS %s' % out_table)
    plpy.execute("""
        CREATE TABLE %s (
            wordid INT4, 
            old_wordid INT4,
            word TEXT
        )
        m4_ifdef(`__GREENPLUM__', `WITH(APPENDONLY=TRUE,COMPRESSTYPE=QUICKLZ)
        DISTRIBUTED BY (wordid)')
        """ % (out_table))

    plpy.execute("""
        INSERT INTO %s
        SELECT r - 1, wordid, word
        FROM
        (
            SELECT
                wordid, word, rank() OVER(ORDER BY wordid) r
            FROM
            (
                SELECT wordid, word
                FROM
                (
                    SELECT 
                        wordid, 
                        word, 
                        rank() OVER(PARTITION BY wordid ORDER BY word ASC) r
                    FROM 
                        %s voc 
                ) t1
                WHERE r = 1
            ) t2
        ) t3
        """ % (out_table, vocab_table))

"""
@brief Normalize the data table according to the normalized vocabulary, rows
with non-positive count values will be removed
@param data_table   The data table to be normalized
@param vocab_table  The nomralized vocabulary table
@param output_table The normalized data table
"""
def norm_dataset(data_table, vocab_table, output_table):
    __check_data_table(data_table)    
    __check_norm_vocab_table(vocab_table)
    plpy.execute('DROP TABLE IF EXISTS %s' % (output_table))
    plpy.execute("""
        CREATE TABLE %s (
            docid INT4, 
            wordid INT4, 
            count INT4
        )
        m4_ifdef(`__GREENPLUM__', `WITH(APPENDONLY=TRUE,COMPRESSTYPE=QUICKLZ)
        DISTRIBUTED BY (docid)')
        """ % (output_table))

    plpy.execute("""
        INSERT INTO %s
        SELECT 
            docid, 
            vocab.wordid, 
            count
        FROM
            %s data, 
            %s vocab
        WHERE 
            data.wordid = vocab.old_wordid AND data.count > 0 
        """ % (output_table, data_table, vocab_table))

"""
@brief Co-normalize the data table and the vocabulary table
@param data_table           The data table to be normalized
@param vocab_table          The vocabulary table to be nomralized
@param output_data_table    The normalized data table
@param output_vocab_table   The normalized vocabulary table
"""
def conorm_data(
    data_table, vocab_table, output_data_table, output_vocab_table):
    __check_data_table(data_table)
    __check_vocab_table(vocab_table)

    plpy.execute('DROP TABLE IF EXISTS %s' % (output_data_table))
    plpy.execute("""
        CREATE TABLE %s (
            docid   INT4, 
            wordid  INT4, 
            count   INT4
        )
        m4_ifdef(`__GREENPLUM__', `WITH(APPENDONLY=TRUE,COMPRESSTYPE=QUICKLZ)
        DISTRIBUTED BY (docid)')
        """ % (output_data_table))

    plpy.execute('DROP TABLE IF EXISTS %s' % (output_vocab_table))
    plpy.execute("""
        CREATE TABLE %s (
            wordid      INT4, 
            old_wordid  INT4,
            word        TEXT
        )
        m4_ifdef(`__GREENPLUM__', `WITH(APPENDONLY=TRUE,COMPRESSTYPE=QUICKLZ)
        DISTRIBUTED BY (wordid)')
        """ % (output_vocab_table))

    plpy.execute('DROP TABLE IF EXISTS __vocab__')
    plpy.execute("""
        CREATE TEMP TABLE __vocab__(
            wordid  INT4, 
            word    TEXT
        )
        m4_ifdef(`__GREENPLUM__', `WITH(APPENDONLY=TRUE,COMPRESSTYPE=QUICKLZ)
        DISTRIBUTED BY (wordid)')
        """) 

    plpy.execute("""
        INSERT INTO __vocab__
        SELECT voc.wordid, voc.word
        FROM
        (
            SELECT
                wordid 
            FROM
                %s data 
            GROUP BY wordid
        ) tvoc,
        %s voc
        WHERE tvoc.wordid = voc.wordid
        """ % (data_table, vocab_table))
    norm_vocab('__vocab__', output_vocab_table)
    norm_dataset(data_table, output_vocab_table, output_data_table)

"""
@brief Return the index of elements in a sorted order
@param vector   The array to be sorted
@return         The index of elements
"""
def index_sort(vector):
    dim = len(vector)
    idx = range(dim)
    idx.sort(key = lambda r: vector[r])

    return map(lambda r: r + 1, idx)

"""
@brief Convert the format of data table from <docid, wordid, count> to <docid,
wordcount, words, counts>.
@param data_table   The data table to be converted
@param return       The converted table name
"""
def __convert_data_table(madlib_schema, data_table):
    plpy.info('converting the data table ...')
    convt_table = '__newplda_convt_corpus__'
    plpy.execute('DROP TABLE IF EXISTS %s' % (convt_table))
    plpy.execute("""
        CREATE TEMP TABLE %s
        (
            docid INT4,
            wordcount INT4,
            words INT4[],
            counts INT4[]
        )
        m4_ifdef(`__GREENPLUM__', `WITH(APPENDONLY=TRUE,COMPRESSTYPE=QUICKLZ)
        DISTRIBUTED BY (docid)')
        """ % (convt_table))

    plpy.execute("""
        INSERT INTO %s
        SELECT 
            docid, 
            sum(count) wordcount,
            %s.array_agg(wordid) words,
            %s.array_agg(count) counts
        FROM
            %s data
        GROUP BY docid
        """ % (convt_table, madlib_schema, madlib_schema, data_table))

    return convt_table

"""
@brief if the given condition is false, then raise an error with the message
@param condition    the condition to be asserted
@param msg          the error message to be reported
"""
def __assert(condition, msg):
    if not condition:
        plpy.error(msg)

"""
@brief if the given condition is false, then raise an warning with the message
@param condition    the condition to be asserted
@param msg          the error message to be reported
"""
def __warn(condition, msg):
    if not condition:
        plpy.warning(msg)

"""
@brief Check the structure of the data table
@param data_table   The data table name
"""
def __check_data_table(data_table):
    plpy.info('checking the data table ... ')
    try:
        rv = plpy.execute("""
            SELECT count(*) cnt FROM pg_attribute 
            WHERE 
                attrelid = '%s'::regclass AND
                ((atttypid = 'INT4'::regtype AND attname = 'docid') OR
                (atttypid = 'INT4'::regtype AND attname = 'wordid') OR
                (atttypid = 'INT4'::regtype AND attname = 'count'))
            """ % (data_table))
        __assert(
           rv[0]['cnt'] == 3, 
           """the %s shoudl have docid::INT4, wordid::INT4, count::INT4
           columns""" % (data_table))
    except:
        __assert(0,
           """the %s must exist and should have docid, wordid, and count
           columns""" % (data_table))

"""
@brief Check the validity of the data table
@param data_table   The data table
@param voc_size     The size of vocabulary
"""
def __validate_data_table(data_table, voc_size):
    plpy.info('validating the data table ...')
    __check_data_table(data_table)
    rv = plpy.execute('SELECT count(*) cnt FROM %s WHERE docid < 0' % (data_table))
    __warn(
        rv[0]['cnt'] == 0,
        """%d rows have negative docid - use continous non-negative
        integers for docid for better interpretation""" % (rv[0]['cnt']))

    rv = plpy.execute('SELECT count(*) cnt FROM %s WHERE wordid < 0' % (data_table))
    __assert(
        rv[0]['cnt'] == 0,
        """%d rows have negative wordid - the wordid must range from 0 to
        voc_size - 1""" % (rv[0]['cnt'] == 0))

    rv = plpy.execute("""
        SELECT 
            count(wordid) size, 
            min(wordid) min_wordid, 
            max(wordid) max_wordid
        FROM
        (
            SELECT wordid 
            FROM %s
            GROUP BY wordid
        ) t1
        """ % (data_table))
    __assert(
        rv[0]['size'] <= voc_size,
        """the actual size of vocabulary %d is larger than the specified %d -
        set the correct voc_size and try again""" % (rv[0]['size'], voc_size))
    __assert(
        rv[0]['min_wordid'] <= voc_size - 1 and
        rv[0]['max_wordid'] <= voc_size - 1,
        """the wordid should be in the range of 0 to %d""" % (voc_size - 1))
    __warn(
        rv[0]['size'] == voc_size,
        """the actual size of vocabulary %d is little than the specified %d -
        the vocabulary and dataset normalization is highly recommended for
        memory efficiency""" % (rv[0]['size'], voc_size))
    __warn(
        rv[0]['min_wordid'] == 0,
        """the actual min wordid is large than 0 - the vocabulary and dataset
        normalization is highly recommended for memory efficiency""")
    __warn(
        rv[0]['max_wordid'] == voc_size - 1,
        """the actual max wordid is smaller than the specified (voc_size - 1 =
        %d) - set the voc_size to %d for memory efficiency""" % (voc_size - 1,
        rv[0]['max_wordid'] + 1))

    rv = plpy.execute('SELECT count(*) cnt FROM %s WHERE count <= 0' % (data_table))
    __assert(
        rv[0]['cnt'] == 0,
        """%d rows have zero or negative count - the value in the count column
        must be positive integers""" % (rv[0]['cnt'] == 0))

"""
@brief Check the validity of the vocabulary table
@param vocab_table   The vocabulary table name
"""
def __check_vocab_table(vocab_table):
    plpy.info('checking the vocabulary table ...')
    try:
        rv = plpy.execute("""
            SELECT count(*) cnt FROM pg_attribute 
            WHERE 
                attrelid = '%s'::regclass AND
                ((atttypid = 'INT4'::regtype AND attname = 'wordid') OR
                (atttypid = 'text'::regtype AND attname = 'word'))
            """ % (vocab_table))
        __assert(
           rv[0]['cnt'] == 2, 
           """the %s should have wordid::INT4, word::TEXT columns""" % (vocab_table))
    except:
        __assert(0,
            """the %s must exist and should have wordid and word columnes""" %
            (vocab_table))

"""
@brief Check the validity of the normalized vocabulary table
@param vocab_table   The normalized vocabulary table name
"""
def __check_norm_vocab_table(vocab_table):
    plpy.info('checking the normalized vocabulary table ...')
    try:
        rv = plpy.execute("""
            SELECT count(*) cnt FROM pg_attribute 
            WHERE 
                attrelid = '%s'::regclass AND
                ((atttypid = 'INT4'::regtype AND attname = 'wordid') OR
                (atttypid = 'INT4'::regtype AND attname = 'old_wordid') OR
                (atttypid = 'text'::regtype AND attname = 'word'))
            """ % (vocab_table))
        __assert(
            rv[0]['cnt'] == 3, 
            """the %s should have wordid, old_wordid, and word columns""" %
            (vocab_table))
    except:
        __assert(0,
           """the %s must exist and should have wordid, old_wordid, and word
           columns""" % (vocab_table))

"""
@brief Check the validity of the model table
@param model_table  Model table name
"""
def __check_model_table(model_table):
    plpy.info('checking the model table ...')
    try:
        rv = plpy.execute("""
            SELECT count(*) cnt 
            FROM pg_attribute 
            WHERE 
               attrelid = '%s'::regclass AND
               ((atttypid = 'INT4'::regtype AND attname = 'voc_size') OR
               (atttypid = 'INT4'::regtype AND attname = 'topic_num') OR
               (atttypid = 'FLOAT8'::regtype AND attname = 'alpha') OR
               (atttypid = 'FLOAT8'::regtype AND attname = 'beta') OR
               (atttypid = 'INT4[]'::regtype AND attname = 'model')) 
           """ % (model_table))
        __assert(
            rv[0]['cnt'] == 5, 
            """the %s must have voc_size::INT4, topic_num::INT4, alpha::FLOAT8,
            beta::FLOAT8, and model::INT4[] columns""" % (model_table))
    except:
        __assert(0,
            """the %s must exist and should have voc_size, topic_num, alpha,
            beta, word_topic, and corpus_topic columns""" % (model_table))

    rv = plpy.execute("""
        SELECT voc_size, topic_num, alpha, beta, 
            array_upper(model, 1) * array_upper(model, 2) model_size, 
            array_upper(model, 2) count_size 
        FROM %s
        """ % (model_table))
    __assert(
        len(rv) > 0, 
        'the %s should not be empty' % (model_table))
    __assert(
        len(rv) == 1, 
        'the %s should have only 1 row' % (model_table))
    __assert(
        rv[0]['voc_size'] > 0, 
        'the voc_size in %s should be a positive integer' % (model_table))
    __assert(
        rv[0]['topic_num'] > 0, 
        'the topic_num in %s should be a positive integer' % (model_table))
    __assert(
        rv[0]['alpha'] > 0, 
        'the alpha in %s should be a positive real number' % (model_table))
    __assert(
        rv[0]['beta'] > 0, 
        'the beta in %s should be a positive real number' % (model_table))
    __assert(
        rv[0]['model_size'] == (rv[0]['voc_size'] + 1) * rv[0]['topic_num'], 
        """the model_size mismatchs with voc_size and topic_num in %s""" %
        (model_table)) 
    __assert(
        rv[0]['count_size'] == rv[0]['topic_num'], 
        """the size of topic counts mismatchs with the topic_num in %s""" %
        (model_table))
