/* ----------------------------------------------------------------------- *//** 
 *
 * @file newplda.sql_in
 *
 * @brief SQL functions for parallel Latent Dirichlet Allocation
 * @date Dec 2012
 *
 * @sa For an introduction to Latent Dirichlet Allocation models, see the 
       module description \ref grp_newplda.
 *
 *//* ------------------------------------------------------------------------*/

m4_include(`SQLCommon.m4')

/**

@addtogroup grp_newplda

@about

Latent Dirichlet Allocation (LDA) is an interesting generative probabilistic
model for natural texts that has received a lot of attention in recent years. 
The model is quite versatile, having found uses in problems like automated 
topic discovery, collaborative filtering, and document classification.

The LDA model posits that each document is associated with a mixture of various
topics (e.g. a document is related to Topic 1 with probability 0.7, and Topic 2
with probability 0.3), and that each word in the document is attributable to
one of the document's topics. There is a (symmetric) Dirichlet prior with
parameter \f$ \alpha \f$ on each document's topic mixture. In addition, there
is another (symmateric) Dirichlet prior with parameter \f$ \eta \f$ on the
distribution of words for each topic.

The following generative process then defines a distribution over a corpus of
documents. 

First sample, for each topic \f$ i \f$, a per-topic word
distribution \f$ \Phi_i \f$ from the Dirichlet(\f$\eta\f$) prior. 

Then for each document:
-# Sample a document length N from a suitable distribution, say, Poisson.
-# Sample a topic mixture \f$ \theta \f$ for the document from the
Dirichlet(\f$\alpha\f$) distribution.  -# For each of the N words:
   -# Sample a topic \f$ z_n \f$ from the multinomial topic distribution \f$
   \theta \f$.  
   -# Sample a word \f$ w_n \f$ from the multinomial word
   distribution \f$
   \Phi_{z_n} \f$ associated with topic \f$ z_n \f$.

In practice, only the words in each document are observable. The topic mixture
of each document and the topic for each word in each document are latent
unobservable variables that need to be inferred from the observables, and this
is the problem people refer to when they talk about the inference problem for
LDA. Exact inference is intractable, but several approximate inference
algorithms for LDA have been developed. The simple and effective Gibbs sampling
algorithm described in Griffiths and Steyvers [2] appears to be the current
algorithm of choice. Our parallel implementation of LDA comes from Wang et al
[3], which is essentially a straightforward parallelisation of the Gibbs
sampling algorithm.

See also http://code.google.com/p/plda/.

@input
The \b corpus/dataset to be analyzed is expected to be of the following form:
<pre>{TABLE|VIEW} <em>data_table</em> (
    <em>docid</em> INTEGER,
    <em>wordid</em> INTEGER,
    <em>count</em> INTEGER
    ...
)</pre>
where \c docid refers to the document ID, \c wordid is the word ID (the index
of a word in the vocabulary), and \c count is the number of occurence of the
word in the document. Note that the wordid and count must be non-negative
integers and it is highly recommended that the wordid ranges from 0 to \c
voc_size - 1, where \c voc_size represents the size of vocabulary.

The \b vocabulary/dictionary that indexes all the words found in the corpus is
of the following form:
<pre>{TABLE|VIEW} <em>vocab_table</em> (
    <em>wordid</em> INTEGER,
    <em>word</em> TEXT,
    ...
)</pre>
where \c wordid refers the word ID (the index of a word in the vocabulary) and
\c word is the actual word.

@usage
- The training (i.e. topic inference) is achieved through the following UDF
    <pre>
        SELECT \ref newplda_train('<em>data_table</em>', '<em>voc_size</em>',
        '<em>topic_num</em>', '<em>iter_num</em>', <em>alpha</em>,
        <em>beta</em>, <em>model_table</em>, <em>output_data_table</em>);
    </pre>
    
    This function stores the resulting model in <tt><em>model_table</em></tt>.
    The table has only 1 row and is in the following form:
    <pre>{TABLE} <em>model_table</em> (
        <em>voc_size</em> INTEGER,
        <em>topic_num</em> INTEGER,
        <em>alpha</em> FLOAT,
        <em>beta</em> FLOAT,
        <em>word_topic</em> INTEGER[],
        <em>corpus_topic</em> INTEGER[])
    </pre>

    This function also stores the topic counts and the topic assignments in
    each document in <tt><em>output_data_table</em></tt>. The table is in the
    following form:
    <pre>{TABLE} <em>output_data_table</em> (
        <em>docid</em> INTEGER,
        <em>wordcount</em> INTEGER,
        <em>words</em> INTEGER,
        <em>counts</em> INTEGER,
        <em>topic_count</em> INTEGER[],
        <em>topic_assignment/em> INTEGER[])
    </pre>

- The prediction (i.e. labelling of test documents using a learned LDA model)
  is achieved using the following UDF 
    <pre>
        SELECT \ref newplda_predict('<em>data_table</em>',
        '<em>model_table</em>', '<em>output_table</em>');
    </pre>
    
    This function stores the prediction results in
    <tt><em>output_table</em></tt>. Each row in the table stores the topic
    distribution and the topic assignments for a docuemnt in the dataset. And
    the table is in the following form: 
    <pre>{TABLE} <em>output_table</em> (
        <em>docid</em> INTEGER,
        <em>wordcount</em> INTEGER,
        <em>words</em> INTEGER,
        <em>counts</em> INTEGER,
        <em>topic_count</em> INTEGER[],
        <em>topic_assignment</em> INTEGER[],
    </pre>

@implementation
The input format for the Parallel LDA module is very common in many machine
learning packages written in various lanugages, which allows users to generate
datasets using any existing document preprocessing tools or import existing
dataset very conveniently. Internally, the input data will be validated and then
converted to the following format for efficiency: 
    <pre>{TABLE} <em>__internal_data_table__</em> (
        <em>docid</em> INTEGER,
        <em>wordcount</em> INTEGER,
        <em>words</em> INTEGER[],
        <em>counts</em> INTEGER[]
    </pre>
where \c docid is the document ID, \c wordcount is the count of words in the
document, \c words is the list of unique words in the document, and \c counts
is the list of number of occurence of each unique word in the document. The
convertion can be done with the help of aggregation functions very easily.

@examp

We now give a usage example.

-# As a first step, we need to prepare a dataset and vocabulary in the appropriate structure.
\code
    CREATE TABLE my_vocab(wordid INT4, word TEXT)
    m4_ifdef(`__GREENPLUM__',`DISTRIBUTED BY (wordid)');
    
    INSERT INTO my_vocab VALUES
    (0, 'code'), (1, 'data'), (2, 'graph'), (3, 'image'), (4, 'input'), (5,
    'layer'), (6, 'learner'), (7, 'loss'), (8, 'model'), (9, 'network'), (10,
    'neuron'), (11, 'object'), (12, 'output'), (13, 'rate'), (14, 'set'), (15,
    'signal'), (16, 'sparse'), (17, 'spatial'), (18, 'system'), (19, 'training');
    
    CREATE TABLE my_training 
    (
        docid INT4, 
        wordid INT4, 
        count INT4
    )
    m4_ifdef(`__GREENPLUM__',`DISTRIBUTED BY (docid)');
    
    INSERT INTO my_training VALUES
    (0, 0, 2),(0, 3, 2),(0, 5, 1),(0, 7, 1),(0, 8, 1),(0, 9, 1),(0, 11, 1),(0, 13,
    1), (1, 0, 1),(1, 3, 1),(1, 4, 1),(1, 5, 1),(1, 6, 1),(1, 7, 1),(1, 10, 1),(1,
    14, 1),(1, 17, 1),(1, 18, 1), (2, 4, 2),(2, 5, 1),(2, 6, 2),(2, 12, 1),(2, 13,
    1),(2, 15, 1),(2, 18, 2), (3, 0, 1),(3, 1, 2),(3, 12, 3),(3, 16, 1),(3, 17,
    2),(3, 19, 1), (4, 1, 1),(4, 2, 1),(4, 3, 1),(4, 5, 1),(4, 6, 1),(4, 10, 1),(4,
    11, 1),(4, 14, 1),(4, 18, 1),(4, 19, 1), (5, 0, 1),(5, 2, 1),(5, 5, 1),(5, 7,
    1),(5, 10, 1),(5, 12, 1),(5, 16, 1),(5, 18, 1),(5, 19, 2), (6, 1, 1),(6, 3,
    1),(6, 12, 2),(6, 13, 1),(6, 14, 2),(6, 15, 1),(6, 16, 1),(6, 17, 1), (7, 0,
    1),(7, 2, 1),(7, 4, 1),(7, 5, 1),(7, 7, 2),(7, 8, 1),(7, 11, 1),(7, 14, 1),(7,
    16, 1), (8, 2, 1),(8, 4, 4),(8, 6, 2),(8, 11, 1),(8, 15, 1),(8, 18, 1),
    (9, 0, 1),(9, 1, 1),(9, 4, 1),(9, 9, 2),(9, 12, 2),(9, 15, 1),(9, 18, 1),(9,
    19, 1);
    
    
    CREATE TABLE my_testing 
    (
        docid INT4, 
        wordid INT4, 
        count INT4
    )
    m4_ifdef(`__GREENPLUM__',`DISTRIBUTED BY (docid)');
    
    INSERT INTO my_testing VALUES
    (0, 0, 2),(0, 8, 1),(0, 9, 1),(0, 10, 1),(0, 12, 1),(0, 15, 2),(0, 18, 1),(0,
    19, 1), (1, 0, 1),(1, 2, 1),(1, 5, 1),(1, 7, 1),(1, 12, 2),(1, 13, 1),(1, 16,
    1),(1, 17, 1),(1, 18, 1), (2, 0, 1),(2, 1, 1),(2, 2, 1),(2, 3, 1),(2, 4, 1),(2,
    5, 1),(2, 6, 1),(2, 12, 1),(2, 14, 1),(2, 18, 1), (3, 2, 2),(3, 6, 2),(3, 7,
    1),(3, 9, 1),(3, 11, 2),(3, 14, 1),(3, 15, 1), (4, 1, 1),(4, 2, 2),(4, 3,
    1),(4, 5, 2),(4, 6, 1),(4, 11, 1),(4, 18, 2);
\endcode

-# To perform training, we call the newplda_train() function with the
appropriate parameters. Here is an example.

\code
    SELECT MADLib.newplda_train('my_training', 20, 5, 10, 5, 0.01,
    'my_model', 'my_outdata');
\endcode

    After a successful run of the newplda_train() function, two tables will be
    generated, one for storing the learned models, and another for storing the
    output data table.
   
    To get the detailed information about the learned model, we can run the
    following commands:

    -# The per-word topic counts
    \code
        SELECT MADLib.newplda_get_word_topic_count('my_model',
        'my_word_topic_count');
    \endcode

    -# The per-topic word counts
    \code
        SELECT MADLib.newplda_get_topic_word_count('my_model',
        'my_topic_word_count');
    \endcode

    -# The topic description by top-k words
    \code
        SELECT * FROM MADLib.newplda_get_topic_desc('my_model',
        'my_vocab', 15, 'my_topic_desc');
    \endcode

    To get te the topic counts and the topic assignments for each doucment, we
    can run the following commands:

    -# The per-document topic counts:
    \code
        SELECT docid, topic_count FROM my_outdata;
    \endcode

    -# The per-document topic counts:
    \code
        SELECT docid, words, counts, topic_assignment FROM my_outdata;
    \endcode

    By scanning \c words, \c counts, and \c topic_assignment together, we can
    get the topic assignment for each word in a document.

-# To use a learned LDA model for prediction (i.e. to label new documents), we can use the following
commands: 

\code
    SELECT MADLib.newplda_predict('my_testing', 'my_model', 'my_pred');
\endcode

    After a successful run of the newplda_predict() function, the prediction
    results will be generated and stored in <em>my_pred</em>. This table has
    the same schema as the <em>my_outdata</em> generated by the newplda_train()
    function.
    
    To get te the topic counts and the topic assignments for each doucment, we
    can run the following commands:

    -# The per-document topic counts:
    \code
        SELECT docid, topic_count FROM my_pred;
    \endcode

    -# The per-document topic counts:
    \code
        SELECT docid, words, counts, topic_assignment FROM my_pred;
    \endcode

    By scanning \c words, \c counts, and \c topic_assignment together, we can
    get the topic assignment for each word in a document.
         
@literature

[1] D.M. Blei, A.Y. Ng, M.I. Jordan, <em>Latent Dirichlet Allocation</em>,
    Journal of Machine Learning Research, vol. 3, pp. 993-1022, 2003.
[2] T. Griffiths and M. Steyvers, <em>Finding scientific topics</em>, PNAS,
    vol. 101, pp. 5228-5235, 2004.
[3] Y. Wang, H. Bai, M. Stanton, W-Y. Chen, and E.Y. Chang, <em>PLDA: Parallel
    Dirichlet Allocation for Large-scale Applications</em>, AAIM, 2009.
[4] http://en.wikipedia.org/wiki/Latent_Dirichlet_allocation
[5] J. Chang, Collapsed Gibbs sampling methods for topic models, R manual,
    2010.

@sa File newplda.sql_in documenting the SQL functions.
*/

-- UDT for summarizing a UDF call
DROP TYPE IF EXISTS MADLIB_SCHEMA.newplda_result;
CREATE TYPE MADLIB_SCHEMA.newplda_result AS
(
    output_table    TEXT,
    description     TEXT
);

/**
 * @brief This UDF provides an entry for the plda training process.
 * @param data_table        Table storing the training dataset, each row is in
 *                          the form of <docid, wordid, count> where docid,
 *                          wordid, and count are all non-negative integers.
 * @param voc_size          Size of the vocabulary (Note that the wordid should
 *                          be continous integers starting from 0 to voc_size -
 *                          1.  A data validation rountine will be called to
 *                          validate the dataset.)
 * @param topic_num         Number of topics (e.g. 100)
 * @param iter_num          Number of iterations (e.g. 60)
 * @param alpha             Dirichlet parameter for the per-doc topic multinomial
 *                          (e.g. 50/topic_num)
 * @param beta              Dirichlet parameter for the per-topic word multinomial
 *                          (e.g. 0.01)
 * @param model_table       Table storing the learned models (voc_size, topic_num, 
 *                          alpha, beta, per-word topic counts, and
 *                          corpus-level topic counts)
 * @param output_data_table Table storing the output data table in the form of
 *                          <docid, wordcount, words, counts, topic_count,
 *                          topic_assignment>
 **/
CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.newplda_train
(
    data_table          TEXT, 
    model_table         TEXT,
    output_data_table   TEXT,
    topic_num           INT4, 
    iter_num            INT4, 
    alpha               FLOAT8, 
    beta                FLOAT8 
)
RETURNS SETOF MADLIB_SCHEMA.newplda_result AS $$
    PythonFunctionBodyOnly(`newplda', `newplda')
    newplda.lda_run(
        schema_madlib, data_table, model_table, output_data_table, topic_num,
        iter_num, alpha, beta, True
    )
    return [[model_table, 'model table'], 
        [output_data_table, 'output data table']]
$$ LANGUAGE PLPYTHONU;


/**
 * @brief This UDF provides an entry for the plda predicton process.
 * @param data_table        Table storing the testing dataset, each row is in
 *                          the form of <docid, wordid, count> where docid,
 *                          wordid, and count are all non-negative integers.
 * @param model_table       Table storing the learned models
 * @param output_data_table Table storing per-document topic counts and topic 
 *                      assignments
 **/
CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.newplda_predict
(
    data_table      TEXT,
    model_table     TEXT,
    output_data_table    TEXT,
    topic_num           INT4, 
    iter_num            INT4, 
    alpha               FLOAT8, 
    beta                FLOAT8 
)
RETURNS SETOF MADLIB_SCHEMA.newplda_result AS $$
    PythonFunctionBodyOnly(`newplda', `newplda')
    newplda.lda_run(
        schema_madlib, data_table, model_table, output_data_table, topic_num,
        iter_num, alpha, beta, False
    )
    return [[
        output_data_table, 
        'per-doc topic distribution and per-word topic assignments']]
$$ LANGUAGE PLPYTHONU;

/**
 * @brief This UDF gets the description for each topic (top-k words) 
 * @param model_table   The model table generated by the training process
 * @param vocab_table   The vocabulary table (<wordid, word>)
 * @param top_k         The number of top words for each topic description 
 * @param desc_table    The output table for storing the per-topic description 
 **/
CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.newplda_get_topic_desc
(
    model_table TEXT,
    vocab_table TEXT,
    desc_table  TEXT,
    top_k       INT4
)
RETURNS SETOF MADLIB_SCHEMA.newplda_result AS $$
    PythonFunctionBodyOnly(`newplda', `newplda')
    newplda.get_topic_desc(
        schema_madlib, model_table, vocab_table, desc_table, top_k)
    return [[
        desc_table, 
        """topic description, use "ORDER BY topicid, prob DESC" to check the
        results"""]]
$$ LANGUAGE plpythonu;

/**
 * @brief L1 normalization with smoothing
 * @param arr       The array to be normalized
 * @param smooth    The smoothing parameter
 * @return          The normalized vector
 **/
CREATE OR REPLACE FUNCTION 
MADLIB_SCHEMA.newplda_util_norm_with_smoothing
(
    arr     FLOAT8[],
    smooth  FLOAT8
)
RETURNS FLOAT8[] AS $$
    PythonFunctionBodyOnly(`newplda', `newplda')
    return newplda.l1_norm_with_smoothing(arr, smooth)
$$ LANGUAGE PLPYTHONU;

/**
 * @brief This UDF returns the index of elements in a sorted order
 * @param arr   The array to be sorted
 * @return      The index of elements
 **/
CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.newplda_util_index_sort
(
    arr FLOAT8[]
)
RETURNS INT4[] AS $$
    PythonFunctionBodyOnly(`newplda', `newplda')
    return newplda.index_sort(arr)
$$ LANGUAGE plpythonu;

/**
 * @brief This UDF assigns topics to words in a document randomly.
 * @param word_count    The count of a word in a document
 * @param topic_num     The number of topics (specified by the user)
 * @return              The topic assignments 
 **/
CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.__newplda_random_assign
(
    word_count  INT4, 
    topic_num   INT4
)
RETURNS INT4[]
AS 'MODULE_PATHNAME', 'newplda_random_assign'
LANGUAGE C STRICT;

/**
 * @brief This UDF learns the topics of a word in a document and is the main
 * step of a Gibbs sampling iteration. 
 * @param topic_assignment  The current topic assignments to the word
 * @param doc_topic         The current current topic counts in the document
 * @param word_topic        The current topic counts for the word
 * @param corpus_topic      The current topic counts for the whole corpus
 * @param alpha             The Dirichlet parameter for per-document topic multinomial             
 * @param beta              The Dirichlet parameter for per-topic word multinomial
 * @return                  The updated topic assignments
 **/
CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.__newplda_gibbs_sample
(
    topic_assignment    INT4[],
    doc_topic           INT4[],
    word_topic          INT4[], 
    corpus_topic        INT4[], 
    alpha               FLOAT8, 
    beta                FLOAT8 
)
RETURNS INT4[] 
AS 'MODULE_PATHNAME', 'newplda_gibbs_sample'
LANGUAGE C STRICT;

/**
 * @brief This UDF is the sfunc for the aggregator computing the topic counts
 * for each word and/or for each document.
 * @param state             The topic counts
 * @param topic_assignment  The topic assignments in the document
 * @param topic_num         The number of topics
 * @return                  The updated state
 **/
CREATE OR REPLACE FUNCTION 
MADLIB_SCHEMA.__newplda_count_topic_sfunc
(
    state               INT4[],
    topic_assignment    INT4[], 
    topic_num           INT4
)
RETURNS INT4[]
AS 'MODULE_PATHNAME', 'newplda_count_topic_sfunc'
LANGUAGE C;

/**
 * @brief This UDF is the prefunc for the aggregator computing the per-word
 * topic counts.
 * @param state1    The local word topic counts
 * @param state2    The local word topic counts
 * @return          The element-wise sum of two local states
 **/
CREATE OR REPLACE FUNCTION 
MADLIB_SCHEMA.__newplda_count_topic_prefunc
(
    state1  INT4[],
    state2  INT4[]
)
RETURNS INT4[]
AS 'MODULE_PATHNAME', 'newplda_count_topic_prefunc'
LANGUAGE C IMMUTABLE STRICT;

/**
 * @brief This uda computes the word topic counts by scanning and summing
 * up topic assignments.
 * @param topic_assignment  The topic assignments in the document
 * @param topic_num         The number of topics
 * @return                  The topic counts
 **/
DROP AGGREGATE IF EXISTS 
MADLIB_SCHEMA.__newplda_count_topic_agg
(
    INT4[], 
    INT4 
);
CREATE AGGREGATE 
MADLIB_SCHEMA.__newplda_count_topic_agg
(
    INT4[], 
    INT4 
)
(
    stype = INT4[],
    sfunc = MADLIB_SCHEMA.__newplda_count_topic_sfunc
    m4_ifdef(
        `GREENPLUM', 
        `, prefunc = MADLIB_SCHEMA.__newplda_count_topic_prefunc'
    )
);

/**
 * @brief This UDF is the sfunc for the aggregator computing the log likelihood
 * @param state             The current log likelihood
 * @param topic_count       The per-word or per-document topic counts
 * @param hyper_parameter   The Dirichlet parameter
 * @return                  The updated state
 **/
CREATE OR REPLACE FUNCTION 
MADLIB_SCHEMA.__newplda_log_likelihood_sfunc
(
    state               FLOAT8,
    topic_count         INT4[],
    hyper_parameter     FLOAT8
)
RETURNS FLOAT8
AS 'MODULE_PATHNAME', 'newplda_log_likelihood_sfunc'
LANGUAGE C IMMUTABLE STRICT;

/**
 * @brief This UDF is the prefunc for the aggregator computing the log
 * likelihood.
 * @param state1    The local log likelihood
 * @param state2    The local log likelihood
 * @return          The sum of two local states
 **/
CREATE OR REPLACE FUNCTION 
MADLIB_SCHEMA.__newplda_log_likelihood_prefunc
(
    state1  FLOAT8,
    state2  FLOAT8
)
RETURNS FLOAT8
AS 'MODULE_PATHNAME', 'newplda_log_likelihood_prefunc'
LANGUAGE C IMMUTABLE STRICT;

/**
 * @brief This uda computes the log likelihood.
 * @param topic_count       The per-word or per-document topic counts
 * @param hyper_parameter   The Dirichlet parameter
 * @return                  The log likelihood
 **/
DROP AGGREGATE IF EXISTS 
MADLIB_SCHEMA.__newplda_loglikelihood_agg
(
    INT4[], 
    FLOAT8
);
CREATE AGGREGATE 
MADLIB_SCHEMA.__newplda_loglikelihood_agg
(
    INT4[], 
    FLOAT8
)
(
    stype = FLOAT8,
    initcond = '0.0',
    sfunc = MADLIB_SCHEMA.__newplda_log_likelihood_sfunc
    m4_ifdef(
        `GREENPLUM', 
        `, prefunc = MADLIB_SCHEMA.__newplda_log_likelihood_prefunc'
    )
);

/**
 * @breif This UDF is the sfunc of the aggregator getting the first value of a
 * column in a segment.
 * @param state     The first value
 * @param val       The value of a column in a row
 * @return          The updated state 
 **/
CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.__newplda_first_sfunc
(
    state INT4, 
    val INT4
)
RETURNS INT4
AS 'MODULE_PATHNAME', 'newplda_first'
LANGUAGE C IMMUTABLE STRICT;

/**
 * @brief This uda gets the first value of a column in a table per-segment.
 * @param val   The value of the column in a row
 * @return      The first value of the column in a segment
 **/
DROP AGGREGATE IF EXISTS
MADLIB_SCHEMA.__newplda_first
(
    INT4
);
CREATE AGGREGATE 
MADLIB_SCHEMA.__newplda_first
(
    INT4
)
(
    sfunc = MADLIB_SCHEMA.__newplda_first_sfunc,
    stype = INT4
);
